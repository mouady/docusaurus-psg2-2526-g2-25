# Informe t√©cnico: metodolog√≠a de gesti√≥n de configuraci√≥n (A1.4)

**Asignatura:** Proceso Software y Gesti√≥n II (Grado en Ingenier√≠a del Software, Universidad de Sevilla) 

**Curso acad√©mico:** 2025/2026  

**Grupo:** PSG2-2526-G2-25    

**Repositorio:** https://github.com/gii-is-psg2/psg2-2526-g2-25

**Integrantes:**

- Mohamed Ahmed El Ouadih
- Manuel Duarte √Ålvarez
- Candelaria Olmos Pay√°n
- Enrique Julio Purcell Cichy
- Jos√© Antonio Reina Navarro


## Resumen

Este documento define la metodolog√≠a de gesti√≥n de configuraci√≥n del proyecto, incluyendo est√°ndares de codificaci√≥n, pol√≠ticas de commits, estructura de repositorio, estrategia de ramificaci√≥n basada en Git Flow, versionado sem√°ntico, definici√≥n de hecho y gesti√≥n de documentaci√≥n.

## √çndice

1. [Coding standards](#1-coding-standards)
2. [Pol√≠ticas de mensajes de commit](#2-pol√≠ticas-de-mensajes-de-commit)
3. [Estructura de repositorios y ramas por efecto](#3-estructura-de-repositorios-y-ramas-por-defecto)
4. [Branching strategy](#4-branching-strategy)
   - a. [How to develop feature branches](#a-how-to-develop-feature-branches)
   - b. [How to prepare releases](#b-how-to-prepare-releases)
   - c. [How to fix bugs in production](#c-how-to-fix-bugs)
5. [Pol√≠ticas de versionado](#5-pol√≠ticas-de-versionado)
6. [Definici√≥n de "hecho"](#6-definici√≥n-de-hecho)
7. [Manejo de documentaci√≥n en el repositorio](#7-manejo-de-documentaci√≥n-en-el-repositorio)
8. [Informe de iTop y del CMDB](#8-informe-de-itop-y-del-cmdb)


## 1. Coding standards

Para mantener la cohesi√≥n en nuestro desarrollo, la estructura visual del archivo comienza con un espacio en blanco entre el bloque de imports y la definici√≥n de la clase. Una vez dentro de la clase, dejaremos tambi√©n un espacio antes de comenzar el bloque de atributos, los cuales deben ir agrupados sin espacios entre ellos para mantener la densidad. Al definir los m√©todos, volveremos a separar cada uno por una l√≠nea en blanco para mejorar la legibilidad. En cuanto a las estructuras de control como if, else o for, la llave de apertura se coloca en la misma l√≠nea que la sentencia, y el c√≥digo debe comenzar inmediatamente en la l√≠nea siguiente, utilizando siempre las tabulaciones por defecto del sistema.

En el apartado de nombramientos, las clases y DTOs seguir√°n el formato ClinicDTO (respetando las siglas en may√∫sculas), mientras que para los atributos utilizaremos siempre camelCase. Esta misma convenci√≥n de camelCase se aplicar√° en React para asegurar la simetr√≠a entre el backend y el frontend. Adem√°s, es fundamental que los Enums se declaren dentro de su entidad correspondiente. Visualmente, las anotaciones deben organizarse en estructura de torre, lo que significa colocar estrictamente una anotaci√≥n por l√≠nea justo encima del elemento al que afectan.

Por √∫ltimo, para cerrar el flujo de trabajo, cualquier prueba que se desarrolle debe respetar estrictamente la estructura de tests ya definida en el proyecto, garantizando que el mantenimiento sea sencillo para todo el equipo.

## 2. Pol√≠ticas de mensajes de commit

Nuestra pol√≠tica de mensajes de commit estar√° basada en [Conventional Commits 1.0.0](https://www.conventionalcommits.org/en/v1.0.0/). A continuaci√≥n, se describe la pol√≠tica a usar en nuestros mensajes de commits. 

### Estructura
 
```
<type>(<optional scope>): <description>

<optional body>

<optional footer>
```

A partir de este esquema general, profundizaremos en cada elemento del mensaje de commit:

**1. Tipo (`<type>`):**
Hace referencia al tipo de commit que podemos realizar sobre el repositorio. Podemos diferenciar entre los tipos: 
- `feat`: introduce una nueva feature al c√≥digo base. 
- `docs`: introduce nuevos informes o cambios en los mismos. 
- `fix`: introduce arreglo de bug en el c√≥digo.
- `refactor`: introduce refactorizaci√≥n sobre determinado c√≥digo.
- `test`: introduce pruebas.
- `style`: introduce cambios de estilo para la aplicaci√≥n web.

**2. Scope (`<optional scope>`):**

Es opcional y hace referencia al trozo de c√≥digo afectado en el commit.

**3. Descripci√≥n (`<description>`):**

Resumen corto en tiempo presente. 

**4. Cuerpo (`<optional body>`):**

Explicaci√≥n opcional m√°s detallada.

**5. Footer (`<optional footer>`):**

Campo opcional que podemos usar para:

- BREAKING CHANGE: `<description>`. 
- Fixes #issue: para cerrar la issue.
- Refs #issue: para referenciar otra issue. 
 
---

### Ejemplos Pr√°cticos

**Commit b√°sico con tipo y descripci√≥n:**
```
feat: add pet appointment module
```

**Commit con scope:**
```
fix(api): resolve null pointer exception in getPetById
```

**Commit con cuerpo explicativo:**
```
refactor(database): optimize query performance

Changed the database queries to use indexed fields
and reduced the number of joins, improving response
time by approximately 40%.
```

**Commit con breaking change:**
```
feat(auth)!: change authentication token format

BREAKING CHANGE: The authentication token format has been changed
from JWT to a custom format. All existing tokens will be invalidated
and users will need to log in again.
```

**Commit que cierra una issue:**
```
fix(login): correct password validation logic

The password validation was not checking for special
characters correctly, allowing weak passwords.

Fixes #42
```

**Commit que referencia m√∫ltiples issues:**
```
docs: update API documentation

Added examples for all endpoints and updated
parameter descriptions.

Refs #15, #23, #31
```

---

### Reglas y Buenas Pr√°cticas

1. **Descripci√≥n:**
   - Debe estar en min√∫sculas.
   - No debe terminar en punto.
   - M√°ximo 70 caracteres.
   - Usar imperativo presente. 

2. **Cuerpo:**
   - Separar del t√≠tulo con una l√≠nea en blanco.
   - Explicar el "qu√©" y el "por qu√©", no el "c√≥mo".
   - M√°ximo 70 caracteres por l√≠nea.

3. **Breaking Changes:**
   - A√±adir `!` despu√©s del tipo/scope: `feat!:` o `feat(api)!:`
   - Siempre incluir `BREAKING CHANGE:` en el footer con explicaci√≥n

4. **Scopes sugeridos para nuestro proyecto:**
   - `auth`: autenticaci√≥n y autorizaci√≥n.
   - `api`: endpoints y controladores,
   - `database`: modelos y migraciones,
   - `ui`: componentes de interfaz,
   - `test`: pruebas unitarias e integraci√≥n.
   - `docs`: documentaci√≥n.

---

### Commits NO Permitidos

‚ùå **Evitar:**
```
Update file
Fixed bug
WIP
asdfgh
Merge branch 'main'
```

‚úÖ **Correcto:**
```
fix(auth): prevent login with invalid credentials
feat(user): add profile picture upload
docs(readme): update installation steps
```

---

### Verificaci√≥n de Commits

Antes de hacer push, verifica que tu commit cumple:

- Tiene un tipo v√°lido (`feat`, `fix`, `docs`, etc.).
- La descripci√≥n es clara y concisa.
- Usa imperativo presente.
- No excede 70 caracteres en el t√≠tulo.
- Si hay breaking changes, est√° marcado correctamente.
- Referencias a issues son correctas.

## 3. Estructura de repositorios y ramas por defecto

## Estructura del repositorio y ramas por defecto

### 3.1 Estructura del repositorio
Para mantener una arquitectura limpia, escalable y manejable, nuestro proyecto utiliza un enfoque de repositorio √∫nico que engloba tanto el c√≥digo del *frontend* como del *backend*, junto con las configuraciones de despliegue y la documentaci√≥n. 

En la ra√≠z del repositorio, la estructura principal se divide en tres grandes bloques: la carpeta **`docs/`**, que contiene toda la documentaci√≥n generada durante el ciclo de vida del proyecto (incluyendo este informe t√©cnico en formato Markdown para facilitar el control de versiones, actas de reuniones y pol√≠ticas); el directorio **`frontend/`**, que aloja el c√≥digo fuente y los recursos de la aplicaci√≥n cliente; y, finalmente, la carpeta **`src/`**, destinada al c√≥digo fuente principal del *backend* desarrollado en Java.

Adem√°s de estos directorios, la ra√≠z contiene varios archivos de configuraci√≥n y *scripts* esenciales para la gesti√≥n automatizada del proyecto:
* **Gesti√≥n de dependencias:** Empleamos **`pom.xml`** junto con los *scripts* de Maven Wrapper (**`mvnw`**, **`mvnw.cmd`** y la carpeta oculta **`.mvn/`**). Esto garantiza que todos los miembros del equipo utilicen exactamente la misma versi√≥n de Maven sin necesidad de instalaciones locales previas.
* **Entornos y despliegue:** La orquestaci√≥n de contenedores para levantar el entorno de desarrollo de forma consistente se define en el archivo **`docker-compose.yml`**.
* **Estandarizaci√≥n y seguridad:** Para asegurar la consistencia en el formato del c√≥digo entre diferentes editores (sangr√≠as, codificaci√≥n, etc.), utilizamos **`.editorconfig`**. Por su parte, los archivos **`.gitignore`** y **`.gcloudignore`** son fundamentales para prevenir la subida de archivos binarios, dependencias locales o credenciales sensibles al control de versiones o a los servidores de Google Cloud.
* **Informaci√≥n general:** El punto de entrada del repositorio es el archivo **`README.md`**, acompa√±ado de un archivo **`info.yml`**.

### 3.2 Ramas por defecto
Dado que nuestra metodolog√≠a de gesti√≥n de la configuraci√≥n se basa estrictamente en **Git Flow**, el repositorio se articula en torno a dos ramas principales de larga duraci√≥n que dictan nuestro flujo de trabajo base:

1. **`main` (Rama de producci√≥n):** Esta rama almacena el historial de versiones oficiales y estables del proyecto. El c√≥digo alojado aqu√≠ debe estar siempre en un estado funcional y listo para su paso a producci√≥n. Para proteger su integridad, los *commits* directos a `main` est√°n estrictamente prohibidos; cualquier actualizaci√≥n debe integrarse obligatoriamente mediante Pull Requests que vengan de `develop`.
2. **`develop` (Rama de integraci√≥n):** Funciona como la rama central para el trabajo diario de los desarrolladores. Es el entorno de integraci√≥n donde se unifica el trabajo de todas las nuevas caracter√≠sticas (*feature branches*) una vez que han sido terminadas y revisadas por otros miembros del equipo.

## 4. Branching strategy

### Ramas principales (lifetime indefinido)

El proyecto seguir√° **Git Flow** como metodolog√≠a de ramificaci√≥n, apoy√°ndonos en dos ramas principales y de vida indefinida: `main` y `develop`.

- **`main`**: rama estable y siempre lista para producci√≥n.  
- **`develop`**: rama de integraci√≥n con los cambios destinados a la pr√≥xima release.

### Ramas de soporte (supporting branches)

Adem√°s, se utilizar√°n ramas de soporte propias de Git Flow:

- **`feature/*`**: desarrollo de nuevas funcionalidades.  
- **`release/*`**: preparaci√≥n de una versi√≥n de producci√≥n.  
- **`hotfix/*`**: correcci√≥n de errores cr√≠ticos detectados en producci√≥n.
- **`fix/*` (convenci√≥n del equipo)**: correcci√≥n de bugs detectados durante el desarrollo (sale de `develop` y vuelve a `develop` v√≠a PR).

### Peer reviews obligatorias (Pull Requests)

Todo cambio de configuraci√≥n/c√≥digo debe ser revisado por al menos un miembro antes de integrarse, en tareas de mayor complejidad se podr√°n 
asignar varios miembros, usando **peer reviews** mediante **Pull Requests**. Esto mejora el entendimiento compartido, refuerza est√°ndares, aumenta la calidad y reduce el "bus factor".

### Adaptaci√≥n obligatoria al proyecto (uso de GitHub)

En este proyecto, Git Flow se aplica con una modificaci√≥n operativa:

- La creaci√≥n de ramas y las fusiones se har√°n obligatoriamente en **GitHub** mediante **Pull Requests**.  
- Todas las ramas deben crearse desde GitHub usando **"Create branch from issue"** y quedar vinculadas a una **Issue** (feature, fix, refactor‚Ä¶).  
- No se permiten merges directos: toda integraci√≥n en `develop` o `main` debe pasar por PR.  
- Los comandos locales de Git Flow se consideran solo informativos y no la forma principal de trabajar en el proyecto.

## a. How to develop feature branches

### Principio general

Las feature branches deben ser **cortas (short-lived)** y orientadas a incrementos peque√±os. El objetivo es integrar a menudo y facilitar la revisi√≥n por PR.

### Flujo de trabajo (adaptado al proyecto)

Proceso para desarrollar una feature:

1. Crear una **Issue** que describa la funcionalidad.  
2. Crear la rama desde GitHub con **Create branch from issue** y asociarla a esa Issue.  
3. Nombrado recomendado: `feature/<id-issue>-<breve-descripcion>`.  
4. La rama `feature/*` sale de `develop` (base de la pr√≥xima release) y se publica en remoto (GitHub) para trazabilidad.

### Revisi√≥n e integraci√≥n (PR)
Al cerrar la PR, la integraci√≥n debe evitar "fast-forward" y dejar un **merge commit** (equivalente a `--no-ff`) para que quede visible el historial de la feature y sea m√°s f√°cil auditar/revertir.

## b. How to prepare releases

### Objetivo de las release branches

Las ramas `release/*` se usan para preparar una nueva versi√≥n de producci√≥n. En esta fase solo se permiten:
- cambios de √∫ltima hora,
- bug fixes menores,
- y metadatos de release (p. ej., documentaci√≥n/versi√≥n).

### Flujo de release (Git Flow)

Proceso est√°ndar:

1. Crear `release/<version>` desde `develop` cuando el conjunto de features planificado est√© listo.  
2. Estabilizar la release con correcciones menores.  
3. Integrar la release en `main` y crear un **tag de versi√≥n** asociado a esa entrega.  
4. Integrar tambi√©n `release/*` de vuelta a `develop` para no perder los ajustes de estabilizaci√≥n.

## c. How to fix bugs

### Bugs en desarrollo 

Los bugs detectados en desarrollo se corrigen como trabajo normal del proyecto:
- se crea una **Issue** del bug,
- se abre una rama vinculada a esa Issue (por ejemplo `fix/*`) partiendo de `develop`,
- y se integra de vuelta a `develop` mediante **Pull Request** con **peer review**.

### Hotfix: bug cr√≠tico en producci√≥n (ya desplegado)

Si el bug es cr√≠tico y est√° en producci√≥n, se usa una rama `hotfix/*` partiendo de `main`, para restaurar r√°pidamente un estado estable.

Flujo Git Flow para hotfix:

1. Abrir una Issue del bug cr√≠tico y crear `hotfix/<version>` desde `main`.  
2. Implementar la correcci√≥n con cambios m√≠nimos y verificables.  
3. Integrar en `main` y etiquetar la nueva versi√≥n (normalmente incremento **patch**).  
4. Integrar tambi√©n en `develop` para que la correcci√≥n quede incluida en el trabajo futuro (salvo que haya una release en curso).

Igual que con el resto del proyecto, se trabaja con ramas ligadas a Issues y PR para integraciones.

## 5. Pol√≠ticas de versionado

El proyecto sigue una estrategia de versionado basada en ***semantic versioning***:

**X.Y.Z**

Donde:

- **X**: cambios incompatibles con versiones anteriores o modificaciones estructurales importantes, que rompen la compatibilidad con la API. Aplicado a este proyecto, salvo en alg√∫n caso excepcional, s√≥lo se cambiar√° la etiqueta **X** cuando se cambie de sprint.
- **Y**: nuevas funcionalidades compatibles con versiones anteriores, cambios menores, o funcionalidades nuevas y mejoras.
- **Z**: correcci√≥n de errores (*bug fixes*), s√≥lo cambios internos para corregir comportamientos incorrectos de la aplicaci√≥n.

> Nota: cuando **X** aumente, se resetear√°n (volver√°n a 0) las dem√°s; y cuando **Y** aumente, se resetear√° **Z**.

## 6. Definici√≥n de "hecho"

Una tarea se considera hecha cuando cumple todos los siguientes criterios, en ning√∫n orden concreto:

- El c√≥digo ha sido revisado y aprobado mediante una *pull request* por al menos otro miembro del equipo.
- Todas las pruebas unitarias y de integraci√≥n relacionadas con el cambio pasan correctamente, cubriendo al menos el 75% del c√≥digo afectado.
- La funcionalidad ha sido probada en el entorno de desarrollo y no provoca errores en dicho entorno.
- La documentaci√≥n t√©cnica asociada est√° completa y actualizada. Se debe especificar expl√≠citamente en la descripci√≥n de la tarea o commit qu√© documentaci√≥n se ve afectada por el cambio (por ejemplo: comentarios en clases `X`, documentaci√≥n de la API en archivos como `docs/api.md`, diagramas de arquitectura, etc.).
- No existen errores de compilaci√≥n tras la implementaci√≥n de la nueva funcionalidad.
- La implementaci√≥n sigue los est√°ndares de codificaci√≥n y estilo acordados por el equipo.
- Cualquier cambio relevante en la base de datos, API o integraciones externas ha sido documentado y testeado.

## 7. Manejo de documentaci√≥n en el repositorio

En este repositorio se ha establecido la siguiente pol√≠tica de gesti√≥n de documentos:

- üìÇ **commitment-agreements** : los commitment agreements en pdf firmados de cada uno de los integrantes
- üìÇ **reports**: los technical reports que se describen en el backlog.
- üìÇ **actas**
    - üìÇ **Sprint 1**
    - üìÇ **Sprint 2**
    - üìÇ **Sprint 3**
    - üìÇ **Sprint 4**

Por cada reunion se generar√° AL MENOS:

- üìÇ **DD-MM-tematica**
    - üìÑ raw-DD-MM-tematica-autor.md
    - üìÑ DD-MM-tematica.md

**Sobre el concepto de raw:** el raw es un borrador en formato markdown que se redacta durante la reunion y que posteriormente se utiliza (no se borra, ni se edita) para generar el acta final. Se pueden generar varios raws por cada autor si es necesario, pero solo hay UN acta final por cada reunion que tiene caracter oficial.

Donde:
- **tematica**: es la tem√°tica de la reuni√≥n. Los valores posibles son:

| Valor | Cu√°ndo usarlo |
|---|---|
| `planning` | Reuni√≥n de planificaci√≥n del sprint. |
| `standup` | Reuniones que se mantienen EN clase de laboratorio. |
| `daily` | Reuniones que se mantienen FUERA de clase de laboratorio. |
| `review` | Reuni√≥n de revisi√≥n al final del sprint. Se presenta el trabajo completado a los interesados y se recoge feedback. |
| `retrospective` | Reuni√≥n de retrospectiva al final del sprint. El equipo reflexiona sobre su forma de trabajar para identificar mejoras. |
- **DD-MM**: es la fecha de la reunion. Ejemplo: 01-10 (1 de octubre).
- **autor**: es el nombre del integrante que ha redactado lo que llamamos el "raw" del acta.

### Uso de plantillas para actas oficiales

Siempre que sea posible, el acta oficial (`DD-MM-tematica.md`) deber√° generarse utilizando la plantilla correspondiente disponible en `docs/templates/`. El uso de estas plantillas es obligatorio para garantizar la uniformidad y coherencia de toda la documentaci√≥n oficial del proyecto.

## 8. Informe de iTop y del CMDB

En esta fase del proyecto, se ha procedido a la implementaci√≥n de una **Base de Datos de Gesti√≥n de Configuraci√≥n (CMDB)** utilizando la herramienta **iTop**. El prop√≥sito es centralizar la gesti√≥n de los activos IT del grupo para asegurar la trazabilidad y disponibilidad de los recursos durante el ciclo de vida del desarrollo.

### 8.1. Objetivos y alcance del CMDB

#### Objetivos:
* **Centralizaci√≥n de activos:** Mantener un registro √∫nico y preciso de todo el hardware y software vinculado a la organizaci√≥n `PSG2-2526-G2-25`.
* **Control de criticidad:** Clasificar los elementos seg√∫n su importancia para la continuidad del trabajo (p. ej., asignando criticidad **"high"** a los equipos port√°tiles principales).
* **Gesti√≥n de interdependencias:** Documentar c√≥mo interact√∫an los diferentes elementos de configuraci√≥n (CIs) para facilitar el an√°lisis de impacto ante posibles fallos o mantenimientos.

#### Alcance:
El inventario abarca todos los recursos f√≠sicos y l√≥gicos utilizados por los miembros del equipo, incluyendo:
* **Sistemas de c√≥mputo:** Ordenadores personales, port√°tiles y dispositivos m√≥viles.
* **Entornos de software:** IDEs como Visual Studio Code, entornos de ejecuci√≥n como Node.js y kits de desarrollo como Java JDK.
* **Perif√©ricos:** Monitores, impresoras y dispositivos de entrada necesarios para la operatividad.

---

### 8.2. Estructura del CMDB y elementos de configuraci√≥n

La estructura se articula en torno a la organizaci√≥n **PSG2-2526-G2-25**, donde cada integrante ha registrado sus activos espec√≠ficos. A continuaci√≥n, se detallan los elementos a√±adidos por cada miembro del grupo:

| Miembro del Grupo | CIs de Hardware (PC / Mobile) | CIs de Software | CIs Perif√©ricos |
| :--- | :--- | :--- | :--- |
| **Candelaria Olmos** | Port√°til Candelaria Olmos | Java (JDK), Node.js, VS Code | ‚Äî |
| **Enrique Purcell Cichy** | P√≥rtatil Enrique Purcell Cichy | VS Code | Rat√≥n Enrique |
| **Jos√© Antonio Reina** | Port√°til Jos√© Antonio Reina Navarro | VS Code | ‚Äî |
| **Manuel Duarte** | Port√°til Manuel Duarte | Visual Studio Manuel Duarte | Rat√≥n Manuel Duarte |
| **Mohamed Ahmed (md)** | mddesk, mdlaptop, mdp17, mdpad | IDE mddesk, IDE mdlaptop | Monitor (P y S), Rat√≥n, Impresora |

---

### 8.3. Relaciones y an√°lisis de dependencias

Un aspecto fundamental de la estructura del CMDB es la vinculaci√≥n l√≥gica entre los elementos. En nuestra implementaci√≥n, se han establecido las siguientes relaciones clave:

* **Software ‚Üí Hardware (Instalaci√≥n):** cada instancia de software se ha vinculado al hardware correspondiente.
* **CI ‚Üí Organizaci√≥n/Contacto (Propiedad):** todos los activos est√°n supeditados a la organizaci√≥n del grupo y vinculados a sus respectivos due√±os mediante la pesta√±a *Contacts*.
* **Estado de producci√≥n:** se ha definido que los equipos principales operen bajo el estado **"production"**.
